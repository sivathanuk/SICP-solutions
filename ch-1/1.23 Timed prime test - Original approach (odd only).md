**Exercise 1.23**. The smallest-divisor procedure shown at the start of this section does lots of  needless testing: After it checks to see if the number is divisible by 2 there is no point in checking to see if  it is divisible by any larger even numbers. This suggests that the values used for test-divisor should  not be 2, 3, 4, 5, 6,..., but rather 2, 3, 5, 7, 9,.... To implement this change, define a procedure next  that returns 3 if its input is equal to 2 and otherwise returns its input plus 2. Modify the smallestdivisor procedure to use (next test-divisor) instead of (+ test-divisor 1). With timed-prime-test incorporating this modified version of smallest-divisor, run the test for  each of the 12 primes found in exercise 1.22. Since this modification halves the number of test steps, you  should expect it to run about twice as fast. Is this expectation confirmed? If not, what is the observed ratio  of the speeds of the two algorithms, and how do you explain the fact that it is different from 2? 

---
**Original (smallest divisor) approach**

```
#lang sicp

; primality original approach - odd only
(define (is-prime-o n)
  (= (smallest-odd-divisor n 2) n))

(define (smallest-odd-divisor n test-divisor)
  (cond ((< n (square test-divisor)) n)
        ((is-even test-divisor) (smallest-odd-divisor
                                 n
                                 (+ test-divisor 1)))
        ((is-divisible n test-divisor) test-divisor)
        (else
         (smallest-odd-divisor n
                               (+ test-divisor 2)))))

; square
(define (square n)
  (* n n ))

; is-even
(define (is-even n)
  (= (remainder n 2) 0))

; divisible?
(define (is-divisible n test)
  (= (remainder n test) 0))

; search primes
(define (search-for-primes start end count)
  (if (and (< start end) (> count 0))
      (cond ((is-prime-o start)
             (begin
               (timed-prime-test start)
               (newline)
               (search-for-primes (+ start 2)
                                  end
                                  (- count 1))))
            ((is-even start)
             (search-for-primes (+ start 1)
                                end
                                count))
            (else
             (search-for-primes (+ start 2)
                                end
                                count)))))

; runtime check
; get start time
(define (timed-prime-test n)
  (start-test n (runtime)))

; find (end-time - start-time)
(define (start-test n start-ts)
  (if (is-prime-o n)
      (report-prime n (- (runtime) start-ts))))

; display the time taken
(define (report-prime n elapsed-time)
  (display n)
  (display " ***time-taken:")
  (display elapsed-time))
  
```

**check**
```
(search-for-primes 10000 100000 3)
(search-for-primes 1000000 10000000 3)
(search-for-primes 100000000 1000000000 3)
(search-for-primes 1000000000 10000000000 3)
(search-for-primes 100000000000 1000000000000 3)
```

**OUTPUT**
```
10007 ***time-taken:9
10009 ***time-taken:6
10037 ***time-taken:7
1000003 ***time-taken:50
1000033 ***time-taken:48
1000037 ***time-taken:9881
100000007 ***time-taken:587
100000037 ***time-taken:509
100000039 ***time-taken:466
1000000007 ***time-taken:1559
1000000009 ***time-taken:3936
1000000021 ***time-taken:1696
100000000003 ***time-taken:21271
100000000019 ***time-taken:26663
100000000057 ***time-taken:22932

```
